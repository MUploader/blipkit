(text "IKL_Guide_structural_axioms"

      (comment

       'This section lists a number of \'structural\' axioms which define a variety of relations, functions and conventions which are useful when writing IKL content, and which also serve to illustrate IKL usage. It is written entirely as commented IKL text. It is not intended to be complete or exhaustive.

       Many of these axioms use sequence markers, since they are intended to apply to case with any number of arguments: in actual use, however, the relations and functions so defined will apply to some fixed number of arguments. Sequence markers are not normally used in actual IKL applied ontologies.

       Comments like this one, with no enclosed IKL, will be used as SECTION HEADERS.')

      (comment 'Randall Schultz\'s CL parser found several errors in an earlier draft.')
      
      (comment ' EQUALITIES')
      
      (comment 'allEqual is a variadic equality'
         
               (forall (x) (allEqual x))

               (forall (x y ...) (iff
                                  (allEqual x y ...)
                                  (and (= x y)(allEqual x ...))
                                  )
                       )

               )

      (comment 'allDifferent is the variadic inequality, requiring a double recursion'

               (forall (x)(allDifferent x))

               (forall (x y ...) (iff
                                  (allDifferent x y ...)
                                  (and
                                   (not (= x y))
                                   (allDifferent x ...)
                                   (allDifferent y ...)
                                   )
                                  ))

               )

      (comment 'Equality in IKL is a strong statement since it requires that the equated names play all the same roles. Weaker forms of equality allow things to be extensionally equivalent as classes, relations, functions or propositions without making stronger identity claims.'

               (forall (x y)(iff
                             (equivalentRelation x y)
                             (forall (...)(and (iff (x ...)(y ...))))
                             ))

               (forall (x y)(iff
                             (equivalentProperty x y)
                             (forall (u v)(iff (x u v)(y u v)))
                             ))

               (forall (x y)(iff
                             (equivalentClass x y)
                             (forall (u)(iff (x u)(y u)))
                             ))
                       
               (forall (x y)(iff
                             (equivalentProp x y)
                             (iff (x)(y))
                             ))

               (forall (x y)(iff
                             (equivalentFunction x y)
                             (forall (...)(= (x ...)(y ...)))
                             ))

               (forall (x y)(iff
                             (equivalentBinaryFunction x y)
                             (forall (u v)(= (x u v)(y u v)))
                             ))

               )

      (comment ' PATTERNS OF VARIADICITY')

      (comment 'Extending a unary predicate to multiple arguments, applied singly. A simple, useful technique which is here applied to itself.'

               (Predicative)

               (forall (x)(iff
                           (Predicative x)
                           (forall (u ...)(iff (x u ...)(and (x u)(x ...))))
                           ))

               (Predicative Predicative)

               )

      (comment 'an illustrative example'
               (Predicative isHuman)
               (isHuman "Osama bin Laden" Pat_Hayes ChristopherMenzel (father "JohnKerry"))
               )

      (comment 'Extending a binary relation to apply to a linearly ordered sequence of arguments, taken two at a time. In contrast to the previous example, this is expressed as a function from the binary case to the more general case, rather than as a predicate.'

               (forall (x u v)(iff
                               ((chain x) u v ...)
                               (and (x u v)((chain x) v ...))
                               ))
               )

      (comment 'The terminating case here is when we get to a single argument in the chain.'

               (forall (x y)((chain x) y))

               )

      (comment 'an illustrative example'
               (= ascendingOrder (chain lessThan))
               (ascendingOrder 2 5 7 24 136 4283)
               )
      
      

      (comment ' SEQUENCE MARKERS VS. ARGUMENT LISTS')

      (comment 'One can define any of the several ways of describing recursive list structures in IKL using just one application of sequence markers, so that then all other uses of sequence markers can be replaced by the use of explicit argument lists. This technique of using argument lists for expressing variable-length argument sequences is widely used in programming languages and in RDF and OWL, but it can result in very opaque expressions, and it requires the lists to be considered to be first-class objects in the domain of discourse. We give the entire theory here as a reference source for interested readers, without endorsement.')

      (comment 'basic list axiom. Applies to any sequence, no recursion needed.'

               (forall (...)(List (list ...)))

               )

      (comment 'LISP style functional reduction to the binary case, using a constructor function. This mirrors Lisp S-expression syntax in IKL.'
               (= (list) nil)
               (forall (x ...) (= (list x ...)(cons x (list ...)) ))
               (forall (x y)(and (= (car (cons x y)) x) (= (cdr (cons x y)) y) ))
               )

      (comment 'An alternative vocabulary'
               (= car hd)(= cdr tl)(= cons mklist)(= List isList)
               )

      (comment 'RDF style relational reduction to the binary case, using qname abbreviations from the RDF namespace. This mirrors the RDF collection vocabulary and reasoning in IKL.'
               (= (list) rdf:nil)
               (forall (x ...) (and
                                (rdf:first (list x ...) x)
                                (rdf:next (list x ...) (list ...))
                                ))
               )

      (comment 'These different conventions are all mutually consistent so could be asserted at once, allowing "mixed" conventions to be used, but it would be more natural to choose a single convention and use it.')

      (comment 'Predicates on relations and functions which are true when they accept argument sequences expressed as explicit lists. Any of the reductions to a binary case can then be used to encode the argument lists.'

               (forall ((r ListableRelation)...)(iff (r ...)(r (list ...)) ))
               (forall ((f ListableFunction)...)(= (f ...)(f (list ...)) ))

               (Predicative ListableRelation ListableFunction)
               
               )

      (comment 'As an illustrative example, this re-defines Predicative using argument lists instead of sequence markers, using the Lisp-style binary reduction. Compare the the earlier definition to see how the conversion works: the sequence marker represents the tail of the argument list; the trivial empty case has be stated relative to the empty list rather than an empty argument sequence; and the argument restriction to a List should be stated explicitly. Note that this version of Predicative is always a unary predicate which applies to a single list: this is typical of the "argument list" axiomatic style.'

               (Listable Predicative)
               (Predicative nil)
               (forall (x)(iff
                           (Predicative x)
                           (forall (u (l List))(iff (x (cons u l))(and (x u)(x l))))
                           ))
               
               (Predicative (cons Predicative nil))
               
               )

      (comment ' DESCRIPTION LOGIC CONSTRUCTIONS.')

      (comment 'Description logics such as OWL describe relationships between classes (unary relations in IKL) and properties (IKL binary relations.) Typically they provide a variety of ways to construct classes from others, assert properties of classes and properties, and to relate them to one another. All of these can be described directly in IKL. The construction operations are naturally defined as functions on relations, taking advantage of the syntactic freedom afforded by Common Logic.

               We give these definitions using a natural vocabulary, and then relate this to the OWL/RDF vocabulary.')

      (comment 'Boolean operations on classes'

               (forall (x) ((AND) x))
               (forall (c y ...)(iff
                                 ((AND c ...) y)
                                 (and (c y) ((AND ...) y) )
                                 ))

               (forall (x)(not ((OR) x)))
               (forall (c y ...)(iff
                                 ((OR c ...) y)
                                 (or (c y) ((OR ...) y) )
                                 ))

               (forall (c y)(iff ((NOT c) y)(not (c y)) ))

               (= 'AND' (frameworkName OWL 'owl:intersectionOf'))
               (= 'OR' (frameworkName OWL 'owl:unionOf'))
               (= 'NOT' (frameworkName OWL 'owl:complementOf'))

               )

      (comment 'Relationships between classes, properties and individuals'

               (forall (x c)(iff (rdf:type x c)(c x)))

               (forall (c d)(iff (IF c d)(forall (x)(if (c x)(d x))) ))

               (forall (c d)(iff (IFF c d)(forall (x)(iff (c x)(d x))) ))

               (= IF owl:subClassOf)(= IFF owl:equivalentClass)

               (forall (c d)(iff (IF2 c d)(forall (x y)(if (c x y)(d x y))) ))

               (forall (c d)(iff (IFF2 c d)(forall (x y)(iff (c x y)(d x y))) ))

               (= 'IF' (frameworkName OWL 'owl:subPropertyOf'))
               (= 'IFF' (frameworkName OWL 'owl:equivalentProperty'))

               (forall (x y ...)(iff ((ONEOF x ...) y)(or (= x y)((ONEOF ...) y)) ))
               (forall (y)(not ((ONEOF) y) ))

               (= 'ONEOF' (frameworkName OWL 'owl:oneOf'))

               (forall (p c z)(iff ((ALLARE p c) z)(forall (u)(if (p z u)(c u))) ))

               (forall (p c z)(iff ((SOMEARE p c) z)(exists (u)(and (p z u)(c u))) ))

               (forall (p x z)(iff ((IS p x) z)(p z x) ))

               (= 'ALLARE' (frameworkName OWL 'owl:allValuesFrom'))
               (= 'SOMEARE' (frameworkName OWL 'owl:someValuesFrom'))
               (= 'IS' (frameworkName OWL 'owl:hasValue'))

               (forall (c d)(iff (INVERSE c d)(forall (x y)(iff (c x y)(d y x))) ))

               (= 'INVERSE' (frameworkName OWL 'owl:inverseOf'))

               (comment 'note main connective used in the following is if, not iff. See OWL documentation for explanation.'

                        (forall (p c)(if (DOMAIN p c)(forall (x y)(if (p x y)(c x)))))

                        (forall (p c)(if (RANGE p c)(forall (x y)(if (p x y)(c y)))))

                        (= 'RANGE' (frameworkName OWL 'rdfs:range'))
                        (= 'DOMAIN' (frameworkName OWL 'rdfs:domain'))
                        
                        )
               )
)