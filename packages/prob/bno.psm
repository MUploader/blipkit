target(obs/1).

values(p(_,_),[yes,no]).

obs(AVL):- class_list(CL),findall(C=_,member(C,CL),AVL),obs(AVL,CL).

obs(_,[]).
%obs([A=V|AVL],[A|AL]):-
obs(AVL,[A|AL]):-
	member(A=V,AVL),
	children(A,CL),
	classlist_vals(CL,AVL,Vals),
	msw(p(A,Vals),V), % todo
	obs(AVL,AL).

classlist_vals([],_,[]).
classlist_vals([A|AL],AVL,[V|VL]):-
	member(A=V,AVL),
	classlist_vals(AL,AVL,VL).

children(X,CL):- findall(C,c(C,X),CL).


class_list([a,b,c,d,e,f]).

class(X):-
	class_list(CL),
	member(X,CL).

% edges in graph. c(X,Y) ==> X -> Y
c(b,a).
c(c,a).
c(d,b).
c(e,b).
c(f,b).

% setup
setp:-
	findall(X-Vector,setp(X,Vector),_).

% if c(X,Y) then p(Y|X)=1
setp(X,Vector):-
	class(X),
	children(X,CL),
	vector_perm(CL,Vector),
	member(yes,Vector), % at least one precondition must be true
	writeln(X=Vector),
	set_sw(p(X,Vector),[1,0 ]).

% vector_perm(+L,?Vec)
% given a list L of length N, Vec is unified with a list [V1,V2,...,VN], where each
% member is either yes or no
vector_perm([],[]).
vector_perm([_|L],[V|Vec]):-
	member(V,[yes,no]),
	vector_perm(L,Vec).


